# SD_HW2
# Краткое описание
Это CLI-приложения ВШЭ-банка, позволяющее заводить счета, создавать категории и проводить операции. Можно удалять и изменять все, кроме операций, поскольку это не очень логично (я полагаю, что операции неизменяемые). Также есть возможность экспорта информации о действующих счетах в банке в CSV или JSON файлы.

# Паттерны GoF

### 1. Singleton
Класс `CompositionRoot` - синглтон-обертка над DI контейнером. Взят с семинара.
### 2. Visitor
Интерфейс `IAccountVisitor`, используется для экспорта в файлы. Его реализуют два конкретных экспортера CSV и JSON
### 3. Facade
Приведу один пример: класс `AccountExportService` - простенький фасад - содержит логику экспорта в файлы, скрывая от пользователя сложности.
### 4. Abstract Factory
Интерфейс `IExporterFactory`, его реализуют конкретные фабрики, например,  `CsvExporterFactory`, которые уже создают объекты нужного типа.
### 5. Template Method
Реализуется в виде абстрактного класса `Page`, который задает жизненный цикл страницы - подготовку консоли, рендер страницы и завершение. Почти все, кроме рендера, одинаковое, поэтому мы изменяем в наследниках только render.
### 6. Command
Есть интерфейс `ICommand`, позволяющий выполнять и отменять некоторые команды. Я сделал только команду выполнения операций `ChangeBalanceCommand`, но в будущем при расширении можно добавить и другие.
### 7. Strategy
При экспорте можно выбрать фильтр на счета. В моей программе есть обычный фильтр (пропускает всех) и фильтр миллионеров. Фильтр назначается экспортеру в фабрике, а затем при посещении аккаунтов они им проверяются. 
### 8. Proxy
Есть класс `SecuredAccountExporterProxy` - он хранит в себе реальный класс-экспортер, и требует ввода пароля, чтобы экспортировать данные. (ПАРОЛЬ - 123)

# Принципы SOLID/Grasp
### Solid
### 1. Single Responsibility
Все классы соответствуют - каждый выполняет свою отведенную роль (например, репозитории позволяют взаимодействовать с хранилищами, экспортеры занимаются только экспортом и тд.)
### 2. Принцип Liskov
Все соответствуют. Например, мы можем в `IExporterFactory` подставить любую реализацию. Работает со всеми классами (кроме прокси над сервисом экспорта - там есть авторизация, но это предполагается паттерном).
### 3. Interface Segregation
Интерфейсы минималистичны и включают лишь нужную логику.
### 4. Dependency Inversion
Соблюдается, но я много где использовал статические классы, потому что счел реализацию ими интерфейсов или реализацию их в виде инстанциируемых классов неудобной.
### 5. Open-Closed
Например, реализация главного меню позволяет в теории в рантайме удалять/добавлять опции меню
```cs
private static readonly List<MenuOption> menuOptions =  
[  
    new ("Посмотреть счета",  () => new ShowBankAccountsPage().Run()),  
    new ("Добавить счет", () => new AddAccountPage().Run()),  
    new ("Удалить счет", () => new RemoveAccountPage().Run()),  
    new ("Выйти", () => { Environment.Exit(0);})
];
```
## Grasp
### 1. High cohesion
Классы выполняют конкретную задачу и делают минимум лишнего. Например, репозитории, фабрики, сервисы и тд. Есть статический класс `ConsoleMethods`, но он по сути является не классом, а просто набором некоторых методов, которые было просто удобно собрать вместе.
### 2. Low coupling
Зависимости лишь там, где они нужны. Отсутствуют сильно связанные классы.

# Запуск
В директории проекта:
```
dotnet build
dotnet run
```
